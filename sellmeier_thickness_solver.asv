
function sellmeier_thickness_solver()
clc;
clear;
close all;

% 处理附件
[thk1, n2_1, params1, ~] = process_file('附件1.xlsx', 10);
[thk2, n2_2, params2, ~] = process_file('附件2.xlsx', 15);

% 结果
fprintf('\n==================================================\n');
fprintf('最终结果对比分析\n');
fprintf('==================================================\n');
fprintf('附件1 -> 厚度: %.2f μm, 衬底折射率 n2: %.3f\n', thk1, n2_1);
fprintf('附件2 -> 厚度: %.2f μm, 衬底折射率 n2: %.3f\n', thk2, n2_2);
fprintf('厚度差异: %.2f μm (%.2f%%)\n', ...
    abs(thk1-thk2), ...
    abs(thk1-thk2)/mean([thk1,thk2])*100);

% 结果可靠性分析
analyze_reliability(thk1, thk2, params1, params2);
end


function [thk, n2, selParam, n1_all] = process_file(filename, incident_angle)
data = readmatrix(filename);

%% 参数
waveNum = data(:, 1);  % 全波段波数
R = data(:, 2) / 100;  % 全波段反射率
waveLen_full = 10000 ./ waveNum;  % 全波段波长


%% 筛选
filter = waveNum > 1500;
waveNum_fit = waveNum(filter);
R_fit = R(filter);
waveLen_fit = waveLen_full(filter);

%% 初值设置
n_avg_sic = 2.5835;

thk_init = fft_thk_estimate(waveNum_fit, R_fit, n_avg_sic);

n2_init = 2.55;

B1_init = 5.5394;  C1_init = 0.026945;
B2_init = 0.20;  C2_init = 100;
B3_init = 0.05;  C3_init = 0.01;
selParam_init = [B1_init, B2_init, B3_init, C1_init, C2_init, C3_init];


x0 = [thk_init, n2_init, selParam_init];
lb = [thk_init*0.8, 2.0,  0.1, 0.001, 0.0001, 0.0001, 0.1,  0.001];
ub = [thk_init*1.2, 3.5,  20,  10,    5,      2,      150,  20];

%% 拟合
[x_optimal, R_squared_fit] = global_fit_all_parameters(x0, lb, ub, waveNum_fit, R_fit, waveLen_fit, incident_angle);

thk = x_optimal(1);
n2 = x_optimal(2);
selParam = x_optimal(3:8);

%% 打印
fprintf('\n--- 拟合完成 ---\n');
fprintf('最终厚度: %.2f μm\n', thk);
fprintf('最终衬底折射率 n2: %.3f\n', n2);
fprintf('最终塞尔迈耶尔参数:\n');
fprintf('  B1=%.4f, B2=%.4f, B3=%.4f\n', selParam(1), selParam(2), selParam(3));
fprintf('  C1=%.4f, C2=%.4f, C3=%.4f\n', selParam(4), selParam(5), selParam(6));
fprintf('在拟合区域(>1500 cm^-1)的拟合优度 R²: %.4f\n', R_squared_fit);



n1_all = calculate_sellmeier_n(waveLen_full, selParam);

plot_refractive_index(waveLen_full, waveNum, n1_all);
plot_fitting_results(waveNum, R, n1_all, thk, n2, incident_angle);
end

%  全局优化函数
function [x_optimal, R_squared] = global_fit_all_parameters(x0, lb, ub, waveNum_fit, R_fit, waveLen_fit, incident_angle)

theta0_rad = incident_angle * pi / 180;
model_func = @(x, k) model_R(x, k, waveLen_fit, theta0_rad);

options = optimoptions('lsqcurvefit', ...
    'Display', 'iter', 'MaxIterations', 1000, 'FunctionTolerance', 1e-9, ...
    'StepTolerance', 1e-10, 'Algorithm', 'trust-region-reflective', 'UseParallel', true);

[x_optimal, ~] = lsqcurvefit(model_func, x0, waveNum_fit, R_fit, lb, ub, options);

R_fitted = model_func(x_optimal, waveNum_fit);
SS_tot = sum((R_fit - mean(R_fit)).^2);
SS_res = sum((R_fit - R_fitted).^2);
R_squared = 1 - SS_res / SS_tot;
end


%  物理模型与辅助函数
function R = model_R(params, waveNum, waveLen, theta0)
thk = params(1);
n2 = params(2);
selParam = params(3:8);
n1 = calculate_sellmeier_n(waveLen, selParam);
R = model_R_vectorized([thk, n2], waveNum, n1, theta0);
end

function R = model_R_vectorized(params, waveNum, n1, theta0)
thk = params(1); n2 = params(2); n0 = 1.0;
n1 = n1(:); waveNum = waveNum(:);
sin_theta1 = n0 * sin(theta0) ./ n1; cos_theta1 = real(sqrt(1 - sin_theta1.^2));
sin_theta2 = n0 * sin(theta0) / n2; cos_theta2 = real(sqrt(1 - sin_theta2^2));
r01_s = (n0*cos(theta0) - n1.*cos_theta1) ./ (n0*cos(theta0) + n1.*cos_theta1);
r12_s = (n1.*cos_theta1 - n2*cos_theta2) ./ (n1.*cos_theta1 + n2*cos_theta2);
r01_p = (n1*cos(theta0) - n0.*cos_theta1) ./ (n1*cos(theta0) + n0.*cos_theta1);
r12_p = (n2*cos_theta1 - n1.*cos_theta2) ./ (n2*cos_theta1 + n1.*cos_theta2);
delta = 4 * pi * n1 .* thk .* cos_theta1 .* waveNum / 10000;
R_s = abs((r01_s + r12_s .* exp(1i*delta)) ./ (1 + r01_s .* r12_s .* exp(1i*delta))).^2;
R_p = abs((r01_p + r12_p .* exp(1i*delta)) ./ (1 + r01_p .* r12_p .* exp(1i*delta))).^2;
R = (R_s + R_p) / 2; R = real(R(:));
end


function n = calculate_sellmeier_n(waveLen, params)
% 根据塞尔迈耶尔方程计算折射率
B1 = params(1); B2 = params(2); B3 = params(3);
C1 = params(4); C2 = params(5); C3 = params(6);
lambda_sq = waveLen.^2; eps = 1e-10;
term1 = B1 * lambda_sq ./ (lambda_sq - C1 + eps);
term2 = B2 * lambda_sq ./ (lambda_sq - C2 + eps);
term3 = B3 * lambda_sq ./ (lambda_sq - C3 + eps);
n_squared = 1 + term1 + term2 + term3;
n_squared(n_squared < 1) = 1;
n = real(sqrt(n_squared)); n(n < 1) = 1;
end

function thk = fft_thk_estimate(waveNum, R, n_avg)
%根据fft结果计算厚度
R_ac = R - mean(R);
N = 2^nextpow2(8*length(waveNum));
k_uniform = linspace(min(waveNum), max(waveNum), N);
r_uniform = interp1(waveNum, R_ac, k_uniform, 'pchip', 'extrap');
window = hann(N); r_windowed = r_uniform(:) .* window(:);
fft_result = fft(r_windowed); fft_power = abs(fft_result(1:N/2)).^2;
dk = mean(diff(k_uniform));
thk_axis = (0:N/2-1) * 10000 / (2 * n_avg * N * dk);
search_range = find(thk_axis > 5 & thk_axis < 200);
if isempty(search_range), thk = 20; warning('FFT未能找到明显峰值，使用默认厚度初值20um'); return; end
[~, max_idx] = max(fft_power(search_range));
thk = thk_axis(search_range(max_idx));
end

function plot_refractive_index(waveLen, waveNum, n1_all)
figure('Name', '拟合得到的折射率色散曲线', 'Position', [100, 100, 1200, 500]);
subplot(1,2,1); plot(waveLen, n1_all, 'b-', 'LineWidth', 2); xlabel('波长 (μm)'); ylabel('外延层折射率 n_1'); title('折射率 vs 波长'); grid on;
subplot(1,2,2); plot(waveNum, n1_all, 'r-', 'LineWidth', 2); xlabel('波数 (cm^{-1})'); ylabel('外延层折射率 n_1'); title('折射率 vs 波数'); grid on; xlim([min(waveNum), max(waveNum)]);
end

function plot_fitting_results(waveNum, R, n1, thk, n2, incident_angle)
theta0 = incident_angle * pi / 180;
R_fitted = model_R_vectorized([thk, n2], waveNum, n1, theta0);
R_squared_full = 1 - sum((R - R_fitted).^2) / sum((R - mean(R)).^2);

figure('Name', '拟合结果分析 ', 'Position', [150, 150, 1200, 600]);
plot(waveNum, R*100, 'b.', 'MarkerSize', 5, 'DisplayName', '实测数据 ');
hold on;
plot(waveNum, R_fitted*100, 'r-', 'LineWidth', 2, 'DisplayName', '拟合模型');

ylim_vals = ylim;
h = fill([1500, max(waveNum), max(waveNum), 1500], [ylim_vals(1), ylim_vals(1), ylim_vals(2), ylim_vals(2)], 'k', 'FaceAlpha', 0.08, 'EdgeColor', 'none', 'DisplayName', '拟合与处理区域');
uistack(h, 'bottom');

xlabel('波数 (cm^{-1})'); ylabel('反射率 (%)');
title(sprintf('反射率拟合结果 (θ=%d°, d=%.2f μm, n_2=%.3f, 全局R²=%.4f)', ...
    incident_angle, thk, n2, R_squared_full));
legend('Location', 'best'); grid on; xlim([min(waveNum), max(waveNum)]);
end

function analyze_reliability(thk1, thk2, params1, params2)
fprintf('\n=== 结果可靠性分析 ===\n');
thk_diff_percent = abs(thk1-thk2)/mean([thk1,thk2])*100;
fprintf('厚度一致性: 两个角度测得的厚度分别为 %.2f μm 和 %.2f μm，相对差异为 %.2f%%。\n', thk1, thk2, thk_diff_percent);
if thk_diff_percent < 5, fprintf('  -> 结论: 一致性良好，结果可靠。\n');
    fprintf('  -> 推荐厚度值: %.2f ± %.2f μm\n', mean([thk1, thk2]), abs(thk1-thk2)/2);
else, fprintf('  -> 结论: 差异较大，建议检查模型或数据。\n');
end
fprintf('\n塞尔迈耶尔参数稳定性:\n');
param_names = {'B1', 'B2', 'B3', 'C1', 'C2', 'C3'}; is_stable = true;
for i = 1:6, diff = abs(params1(i) - params2(i))/mean([params1(i), params2(i)])*100;
    if diff > 50, is_stable = false;
    end
    fprintf('  %s: %.4f vs %.4f (差异: %.1f%%)\n', param_names{i}, params1(i), params2(i), diff);
end
if is_stable, fprintf('  -> 结论: 参数在不同角度下拟合结果基本稳定。\n');
else, fprintf('  -> 结论: 部分参数在不同角度下拟合结果差异较大，但只要最终的n(λ)曲线和厚度d一致即可。\n');
end
end
