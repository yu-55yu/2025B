clc;
clear;
close all;

file1.path = '附件3.xlsx';
file1.angle = 10;
file2.path = '附件4.xlsx';
file2.angle = 15;

config.waveN_fit_min = 400;
config.n1_init = 3.48;
config.cauchyParam_init = [3.42, 0.05];
config.selParam_init = [10.6684293, 0.0030434748, 1.5413340, 0.301516485, 1.13475115, 1104];
config.k1Param_A_init = 1e-5;
config.k1Param_B_init = 2.0;
config.drudeParam_init = [2000, 200];
config.epsilon_inf = 11.7;

disp('计算厚度初值');
data1 = readmatrix(file1.path);
thk_init1 = fft_thk_estimate(data1(:,1), data1(:,2)/100, config.n1_init, 2000, file1.angle);
data2 = readmatrix(file2.path);
thk_init2 = fft_thk_estimate(data2(:,1), data2(:,2)/100, config.n1_init, 2000, file2.angle);
config.thk_init = mean([thk_init1, thk_init2]);
fprintf('文件3 (10°) FFT估算厚度: %.2f μm\n', thk_init1);
fprintf('文件4 (15°) FFT估算厚度: %.2f μm\n', thk_init2);
fprintf('平均厚度初值: %.2f μm\n', config.thk_init);

disp('--- 开始处理附件3 (10°) ---')
[result1] = process(data1, file1.angle, config, file1.path);
disp('--- 开始处理附件4 (15°) ---')
[result2] = process(data2, file2.angle, config, file2.path);

analyze_res(result1, result2, file1.angle, file2.angle);


function [result] = process(data, angle, config, output_filepath)
    waveNum = data(:, 1);
    R = data(:, 2) / 100;
    waveLen_full = 10000 ./ waveNum;
    filter = waveNum > config.waveN_fit_min;
    waveNum_fit = waveNum(filter);
    R_fit = R(filter);
    waveLen_fit = waveLen_full(filter);
    
    disp('--- Phase 1: 柯西模型粗拟合');
    % 柯西模型参数顺序：[thk, cauchyParam(2), k1Param(2), drudeParam(2)]
    x0_cauchy = [config.thk_init, config.cauchyParam_init, config.k1Param_A_init, config.k1Param_B_init, config.drudeParam_init];
    lb_cauchy = [config.thk_init*0.8, 3.35, 0, 0, 0, 100, 10];
    ub_cauchy = [config.thk_init*1.2, 3.6, 0.2, 1e-3, 4, 4000, 1000];
    
    [x_optimal_cauchy, R_squared_cauchy] = global_fit(x0_cauchy, lb_cauchy, ub_cauchy, waveNum_fit, R_fit, waveLen_fit, angle, config.epsilon_inf, 'cauchy');
    
    fprintf('   Phase 1 完成. R? = %.4f\n', R_squared_cauchy);
    fprintf('   柯西拟合厚度: %.2f μm\n', x_optimal_cauchy(1));
    fprintf('   柯西参数: A=%.3f, B=%.3f\n', x_optimal_cauchy(2), x_optimal_cauchy(3));
    fprintf('   k1参数: A=%.2e, B=%.2f\n', x_optimal_cauchy(4), x_optimal_cauchy(5));
    fprintf('   Drude参数: ν_p=%.1f, Γ=%.1f\n', x_optimal_cauchy(6), x_optimal_cauchy(7));
    
    disp('--- Phase 2: Sellmeier模型精修');
    
    % 基于柯西拟合结果智能设置Sellmeier初始值
    % 使用柯西拟合得到的厚度、k1参数和Drude参数作为基础
    thk_cauchy = x_optimal_cauchy(1);
    k1_cauchy = x_optimal_cauchy(4:5);
    drude_cauchy = x_optimal_cauchy(6:7);
    
    % Sellmeier参数初值可以基于柯西模型的折射率范围来调整
    % 但保持原始的Sellmeier参数作为初始猜测，因为它们的物理意义不同
    x0_sel = [thk_cauchy, config.selParam_init, k1_cauchy, drude_cauchy];
    
    % 基于柯西拟合结果设置更紧的边界
    % 厚度范围：柯西结果的±3%
    thk_range_factor = 0.1;
    lb_thk = thk_cauchy * (1 - thk_range_factor);
    ub_thk = thk_cauchy * (1 + thk_range_factor);
    
    % Sellmeier参数范围：初始值的±20%（因为是不同的色散模型，给予一定自由度）
    sel_range_factor = 0.4;
    lb_sel_params = config.selParam_init * (1 - sel_range_factor);
    ub_sel_params = config.selParam_init * (1 + sel_range_factor);
    
    % k1参数范围：柯西结果的±30%
    k1_range_factor = 0.1;
    lb_k1 = k1_cauchy * (1 - k1_range_factor);
    ub_k1 = k1_cauchy * (1 + k1_range_factor);
    
    % Drude参数范围：柯西结果的±10%
    drude_range_factor = 0.3;
    lb_drude = drude_cauchy * (1 - drude_range_factor);
    ub_drude = drude_cauchy * (1 + drude_range_factor);
    
    % 组合所有下限
    lb_sel = [lb_thk, lb_sel_params, lb_k1, lb_drude];
    ub_sel = [ub_thk, ub_sel_params, ub_k1, ub_drude];
    
    % 确保边界在合理的物理范围内
    lb_sel = max(lb_sel, [config.thk_init*0.7, 0.1, 0.001, 0.0001, 0.0001, 0.1, 1, 0, 0, 50, 5]);
    ub_sel = min(ub_sel, [config.thk_init*1.3, 20, 5, 10, 2, 15, 2000, 1e-3, 4, 5000, 1500]);
    
    % 防止k1参数为负
    if lb_sel(8) < 0
        lb_sel(8) = 0;
    end
    if lb_sel(9) < 0
        lb_sel(9) = 0;
    end
    
    fprintf('   Sellmeier拟合参数范围:\n');
    fprintf('   厚度: [%.2f, %.2f] μm\n', lb_sel(1), ub_sel(1));
    fprintf('   k1_A: [%.2e, %.2e]\n', lb_sel(8), ub_sel(8));
    fprintf('   k1_B: [%.2f, %.2f]\n', lb_sel(9), ub_sel(9));
    fprintf('   ν_p: [%.1f, %.1f] cm??\n', lb_sel(10), ub_sel(10));
    fprintf('   Γ: [%.1f, %.1f] cm??\n', lb_sel(11), ub_sel(11));
    
    [x_optimal_sel, R_squared_sel] = global_fit(x0_sel, lb_sel, ub_sel, waveNum_fit, R_fit, waveLen_fit, angle, config.epsilon_inf, 'sellmeier');

    % 保存结果
    result.thk = x_optimal_sel(1);
    result.selParam = x_optimal_sel(2:7);
    result.k1Param = x_optimal_sel(8:9);
    result.drudeParam = x_optimal_sel(10:11);
    result.n1_complex_full = calculate_n1_complex_sellmeier(waveLen_full, result.selParam, result.k1Param);
    result.n2_complex_full = calculate_n2_complex_drude(waveNum, result.drudeParam, config.epsilon_inf);

    fprintf('   Phase 2 完成. 最终 R? = %.4f\n', R_squared_sel);
    fprintf('   最终厚度: %.2f μm (相对柯西变化: %.2f%%)\n', result.thk, (result.thk - thk_cauchy)/thk_cauchy*100);
    fprintf('   最终外延层 n1 (在 6μm): %.3f + %.4fi\n', real(interp1(waveLen_full, result.n1_complex_full, 6)), imag(interp1(waveLen_full, result.n1_complex_full, 6)));
    fprintf('   最终衬底 Drude 参数 ν_p: %.1f cm??, Γ: %.1f cm??\n', result.drudeParam(1), result.drudeParam(2));
    fprintf('   R?提升: %.4f -> %.4f (Δ=%.4f)\n', R_squared_cauchy, R_squared_sel, R_squared_sel - R_squared_cauchy);

    % 保存结果到Excel
    try
        theta0_rad = angle * pi / 180;
        R_fit_full = compute_R(result.thk, result.n1_complex_full, result.n2_complex_full, waveNum, theta0_rad, 1);
        R_fit_per = R_fit_full * 100;
        writematrix(R_fit_per, output_filepath, 'Sheet', 1, 'Range', 'C2');
        fprintf('   成功将拟合结果保存到: %s\n', output_filepath);
    catch ME
        fprintf('   保存Excel文件时出错: %s\n', ME.message);
    end
    
    % 绘图
    R_fit_plot = compute_R(result.thk, result.n1_complex_full, result.n2_complex_full, waveNum, angle * pi / 180, 1);
    plot_fit_res(waveNum, R, R_fit_plot, angle, config.waveN_fit_min);
    plot_optical_constants(waveLen_full, waveNum, result.n1_complex_full, '外延层 (Sellmeier)');
    plot_optical_constants(waveLen_full, waveNum, result.n2_complex_full, '衬底 (Drude)');
end

% 辅助函数：计算Sellmeier模型的复折射率
function n1_complex = calculate_n1_complex_sellmeier(waveLen, selParam, k1Param)
    B1=selParam(1); B2=selParam(2); B3=selParam(3);
    C1=selParam(4); C2=selParam(5); C3=selParam(6);
    lambda_sq = waveLen.^2;
    eps = 1e-10;
    term1 = B1*lambda_sq./(lambda_sq-C1+eps);
    term2 = B2*lambda_sq./(lambda_sq-C2+eps);
    term3 = B3*lambda_sq./(lambda_sq-C3+eps);
    n_squared = 1 + term1 + term2 + term3;
    n_squared(n_squared < 1) = 1;
    n_real = real(sqrt(n_squared));
    k1_A = k1Param(1); k1_B = k1Param(2);
    k_imag = k1_A * waveLen.^k1_B;
    n1_complex = n_real + 1i * k_imag;
end

% 辅助函数：计算Drude模型的复折射率
function n2_complex = calculate_n2_complex_drude(waveNum, drudeParam, epsilon_inf)
    nu_p = drudeParam(1);
    Gamma = drudeParam(2);
    nu = waveNum(:);
    epsilon_complex = epsilon_inf - (nu_p^2) ./ (nu.^2 + 1i * Gamma * nu);
    n2_complex = sqrt(epsilon_complex);
end